---
title: "Vignette PlasmodeSim"
output:
  pdf_document: default
  html_document:
    df_print: paged
date: "2022-10-19"
---
Welcome to the vignette about the R package PlasmodeSim. This package is still under development.
This package goal is to simulate a new data, that could be used for testing statistical methods that use observational data instead of randomised trials. 

## installing plasmodeSim using remotes
To install using `remotes` run:
```{r, install}
#install.packages("remotes")
#remotes::install_github("GidiusVanDeKamp/PlasmodeSim")
```

## Setting up
This documents skips some parts, we have skipped the steps to obtain a plpModel and plpData. 
````{r, setup fake, eval= F}
plpResultLogistic <- PatientLevelPrediction::loadPlpResult( "yourpathForPlpResult")
plpData <- PatientLevelPrediction::loadPlpData( "yourPathForPlpData" )

````


````{r, setup, message= F, echo = F}

plpResultLogistic <- PatientLevelPrediction::loadPlpResult(
  "~/R/internshipErasmusMC/simulate-new-patients-outcomes/plp_demolog/Result")

plpData<- PatientLevelPrediction::loadPlpData(
  "~/R/internshipErasmusMC/simulate-new-patients-outcomes/plp_demolog/Data" )
````

## Example 1

In this example we obtain new outcomes following a fitted logistic model. We start from a plpModel, then run predictPlp. At last we generate new out comes with the function `newOutcomes` that needs the plpPrediction.
````{r, ex1, message=F}
plpModelLog <- plpResultLogistic$model

plpPrediction <- PatientLevelPrediction::predictPlp(plpModelLog, plpData, plpData$cohorts)

# probabilites <- PlasmodeSim::newPropsParametersPlpModel(plpModelLog, 
#                                                         plpData, 
#                                                         plpData$cohorts)
```` 
The function predictPlp returned this information. 

````{r}
newOut <- PlasmodeSim::newOutcomes(200, plpPrediction)
head(newOut)

````
In the output of newOut patients are drawn randomly with the same probability, the patients could be drawn multiple times. If this happens they can have a different outcome. The function `newOutcomes` needs a data set that contains the columns `rowId` and `value`. The column called `value` contains the probabilities used in generating the new outcomes.
## Example 2 
We here we show how to simulate outcomes from an unfitted logistic model. We use the function `makeLogisiticModel`to specify a logistic model. 

````{R, ex2,message=F } 
Parameters <- plpModelLog$model$coefficients
UnfittedParameters <- Parameters
UnfittedParameters[1,1] <- -0.4
UnfittedParameters[3:5,1] <- 0.4
head(UnfittedParameters)
````
For the logistic model it is necessary that the parameters are stored in a dataset with a column called `betas` and a column called `covariateIds`.  

````{r,message=F}
plpModelunfitted <- PlasmodeSim::makeLogisticModel(UnfittedParameters)
newprobs <- PatientLevelPrediction::predictPlp(plpModelunfitted,
                                               plpData,
                                               plpData$cohorts)
newOut <- PlasmodeSim::newOutcomes(2000, newprobs)
head(newOut)

newOut <- dplyr::distinct(newOut,rowId, .keep_all= TRUE)

modelSettings <- PatientLevelPrediction::setLassoLogisticRegression()
splitSettings <- PatientLevelPrediction::createDefaultSplitSetting()

populationSettings <- PatientLevelPrediction::createStudyPopulationSettings(
  binary = T,
  includeAllOutcomes = FALSE,
  firstExposureOnly = FALSE,
  washoutPeriod = 180,
  removeSubjectsWithPriorOutcome = FALSE,
  priorOutcomeLookback = 99999,
  requireTimeAtRisk = TRUE,
  minTimeAtRisk = 364,
  riskWindowStart = 1,
  startAnchor = 'cohort start',
  riskWindowEnd = 365,
  endAnchor = 'cohort start'
)

# 
# labels <- data.frame(newOut, survivalTime = 12*newOut$outcomeCount)
# trainData <- list(covariateData = plpData$covariateData,
#                   labels= labels,
#                   folds= data.frame(rowId = newOut$rowId,
#                                     index = rep(c(1,2,3,4),length(newOut$rowId)/4)))

population <- PatientLevelPrediction::createStudyPopulation(plpData , 3, populationSettings)
population <- dplyr::filter(population, rowId %in% newOut$rowId)
population <- dplyr::left_join(population, newOut, by = 'rowId') 
head(population)
population <- dplyr::mutate(population, outcomeCount = outcomeCount.y)
population <- dplyr::select(population,-outcomeCount.y, -outcomeCount.x)


population$outcomeCount 

  
trainData <- PatientLevelPrediction::splitData(plpData= plpData, population = population, splitSettings)
weirdFit <- PatientLevelPrediction::fitPlp(trainData$Train,
                                           modelSettings,
                                           analysisId = 'firstTry')

weirdFit$model$coefficients

````

## Visual simulations

The function `visualOutcome` simulates new data and then plots the frequency of the outcome.
Right now the function `visualOutcome` only works for a logistic model. The green line in the plots is the average outcome in the original dataset. 
````{r, visual, message= F, out.width = "60%"}
PlasmodeSim::visualOutcome(plpData,50,200,Parameters)
PlasmodeSim::visualOutcome(plpData,50,200,UnfittedParameters)
````
Here we have plotted 50 times the frequency of the outcome for a simulated dataset with 200 people. 

## Visual of a specific covariate
Say we are interested in the outcomes of a group with a specific covariate. Here we picked the third covariate in the model to visualise. 

````{r, visual2, message= F, out.width = "60%"}

covariateIdToStudy<- plpResultLogistic$covariateSummary$covariateId[3]
UnfittedParameters[3,]

PlasmodeSim::visualOutcomeCovariateId(plpData, 
                                      covariateIdToStudy, 
                                      20,
                                      200, 
                                      UnfittedParameters)
PlasmodeSim::visualOutcomeCovariateId2(plpData,
                                       covariateIdToStudy,
                                       20,
                                       200,
                                       UnfittedParameters)

````

As one can see `visualOutcomeCovariateId` and `visualOutcomeCovariateId2` are very similiar, they both calculate and plot the frequency for a group with a specific covariate present. The small difference is that `visualOutcomeCovariateId` filters a newly simulated dataset set to only keep the patients where the covariate is present, and `visualOutcomeCovariateId2` only simulates new outcomes for patients that have the covariate present. 
We see they are almost the identical only `visualOutcomeCovariateId2` is spread out less because the groups for calculating the frequency with are larger.
