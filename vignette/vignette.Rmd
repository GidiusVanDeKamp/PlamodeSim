---
title: "vignette PlasmodeSim"
output: pdf_document
date: "2022-10-19"
---
Welcome to the vignette about the R package PlasmodeSim. This package is still under development.

```{r,begin , include= F}

# use default LASSO logistic regression

```

## installing plasmodeSim using remotes
To install using `remotes` run:
```{r, install, eval=F}
install.packages("remotes")
remotes::install_github("GidiusVanDeKamp/PlasmodeSim")
```


## Setting up
This documents skips some parts, we have skipped the steps to obtain the plpResults and the plpData. 

We begin by loading the package, together with the package `PatientLevelPrediction`, since the package `PlasmodeSim` is designed to be used with `PatientLevelPrediction`.
````{r, setup, message= F}
library(dplyr) 
library(PlasmodeSim)
library(PatientLevelPrediction)

modelSettings <- PatientLevelPrediction::setLassoLogisticRegression()

plpResultLogistic <- PatientLevelPrediction::loadPlpResult("~/R/internshipErasmusMC/simulate-new-patients-outcomes/plp_demolog/plpResult")

plpData<- PatientLevelPrediction::loadPlpData("~/R/internshipErasmusMC/simulate-new-patients-outcomes/plp_demo/plpData" )
````
In this file we will show which functions are in the `PatientLevelPrediction` package, by adding `PatientLevelPrediction::` before the function. 

## Example 1

In this example we obtain new outcomes of a fitted logistic model.
````{r, ex1, message=F}
plpModelLog <- plpResultLogistic$model
probabilites <- newPropsParametersPlpModel(plpModelLog, plpData, plpData$cohorts)
```` 
The function predictPlp returned this information. 

````{r}
newOut <- newOutcomes(200, probabilites)
head(newOut)

````
In the output of newOut patients are drawed randomly with the same chance, the patients could be drawed multiple times. If this happens they can have a different outcome. The function `newOutcomes` needs a data set where the column that contains the probabilities is called `value`.

## Example 2 
We here we show how to simulate new outcomes from an unfitted logistic model.

````{R, ex2,message=F } 
Parameters <- plpModelLog$model$coefficients
UnfittedParameters <- Parameters
UnfittedParameters[1,1] <- -0.4
UnfittedParameters[2:4,1] <- 0.4
head(UnfittedParameters)
````
For the logistic model it is necessary that the parameters are stored in a dataset with a column called `betas` and a column called `covariateIds`.  

````{r,message=F}
plpModelunfitted <- makeLogisticModel(UnfittedParameters)
newprobs <- PatientLevelPrediction::predictPlp(plpModelunfitted, plpData,plpData$cohorts)
newOut <- newOutcomes(200, newprobs)
head(newOut)
````



## Visual simulations
The function `visualOutcome` simulated new data and then plots the frequency of the outcome.
Right now the function `visualOutcome` only works for a logistic model. The green line in the plots is the average outcome in the original dataset. 
````{r, visual, message= F, out.width = "60%"}
visualOutcome(plpData,50,200,Parameters)
visualOutcome(plpData,50,200,UnfittedParameters)
````
Here we have plotted 50 times the frequency of the outcome for a simulated dataset with 200 people. 

## Visual of a specific covariate

````{r, visual2, message= F, out.width = "60%"}

covariateIdToStudy<- plpResultLogistic$covariateSummary$covariateId[3]
UnfittedParameters[3,]

visualOutcomeCovariateId(plpData, covariateIdToStudy, 20, 200, UnfittedParameters)
visualOutcomeCovariateId2(plpData, covariateIdToStudy, 20, 200, UnfittedParameters)

````

As one can see `visualOutcomeCovariateId` and `visualOutcomeCovariateId2` are very similiar, they both calculate and plot the frequency for a group with a specific covariate present. The small difference is that `visualOutcomeCovariateId` filters a newly simulated dataset set to only keep the patients where the covariate is present, and `visualOutcomeCovariateId2` only simulates new outcomes for patients that have the covariate present. 
We see they are almost the identical only `visualOutcomeCovariateId2` is spread out less because the groups for calculating the frequency with are bigger.

## survival times outcomes. 

For simulating new survival times we need more than one probability, we use the baselinehazard, stored in the plpModel. Now there is a function called `expBetaZ` that returns $\exp(\sum_i \beta_i Z_i)$ where $\beta$ is a vector with the parameters and $Z$ are the covariates of a patients. This could also be included in the function generating new times. (then there would be a posibility that the computer computes things twice, but now maybe it computes expbetaZ's that are never needed). 

````{r, cox model setup, results= 'hide'}
modelSettings <- PatientLevelPrediction::setCoxModel()
plpResult <- PatientLevelPrediction::loadPlpResult("~/R/internshipErasmusMC/simulate-new-patients-outcomes/plp_demoCox/plpResult")
plpModel<- plpResult$model
````

````{R, cox model}
plpModel$trainDetails$modelName

expbetas <- expBetaZ(plpData, plpModel) 

NewOut <- newOutcomesSurvivalTimes(plpModel, expbetas, 20)
head(NewOut) 
````
just as before we have a function to create a dataset that works with the functions.
````{R, cox with changes}
newcoefficients <- plpModel$model$coefficients
newcoefficients[1:3,1]<- 0.4

baselineHazard           <- plpModel$model$baselineHazard$surv[1:45]
timesinthebaselinehazard <- plpModel$model$baselineHazard$time[1:45]
tail(timesinthebaselinehazard)

plpChangedCoxModel <- makeCoxModel(newcoefficients, baselineHazard, timesinthebaselinehazard)
newexpbetas <- expBetaZ(plpData, plpChangedCoxModel) 

NewOut <- newOutcomesSurvivalTimes(plpChangedCoxModel, newexpbetas, 20)
head(NewOut)
````
## To simulated censored data: 
````{R}
plpModelCensoring <-  plpModel #here should be a function that returns the correct estimate
expbetasCensor <-  expbetas #here should be a function that returns the correct values

newCensoredTimes <- newOutcomesCensoredSurvivalTimes(plpModelCensoring, expbetasCensor,
                                                     plpModel, expbetas, 10)
head(newCensoredTimes)

````
## adjusting the baseline

often it is desired to have the same event rate in the newly simulated data as in the original dataset. to do this we have the function `AdjustBaselineSurvival` with this function one can change the baselineSurvival function such that on time `t` the probability is `p`. Because the function `AdjustbaselineSurvival` solves an equation it needs an interval for finding the solution. one can set the event rate 

````{R}
AdjustedBaseline <- AdjustBaselineSurvival(plpModel$model$baselineHazard,
                                        66, 1/2, newexpbetas, intervalSolution = c(-100,100))

AdjustedCoxModel <- makeCoxModel(newcoefficients, AdjustedBaseline$surv, AdjustedBaseline$time)

NewOut <- newOutcomesSurvivalTimes(AdjustedCoxModel, newexpbetas, 20)

head(NewOut)

````



